# 문제 6: 수치적 불안정성 vs 악조건 (10점)

## 📚 강의 노트 참조
- **Lecture 01: Numerical Methods Introduction**
  - p.18-22: Numerical stability and conditioning
  - p.19: Definition of ill-conditioned problems
  - p.20-21: Condition number and its implications

---

## 📋 원본 문제

> **문제 6 (10점)**
>
> 수치적 불안정성 (Numerical Instability)과 악조건 문제 (Ill-Conditioned Problem)의 차이점을 예를 들어 설명하시오.

---

## 🎯 한 줄 요약

| | 수치적 불안정성 | 악조건 문제 |
|---|------------|----------|
| **원인** | **알고리즘**이 나쁨 | **문제 자체**가 어려움 |
| **비유** | 나쁜 운전 | 미끄러운 도로 |

---

## 💡 비유로 먼저 이해하기

### 자동차 운전 비유

```
상황 1: 수치적 불안정성
━━━━━━━━━━━━━━━━━━━━━━
도로: 🛣️ 평범한 도로
운전: 🚗💨 음주운전 (나쁜 알고리즘)
결과: 사고! 💥

→ 도로(문제)는 괜찮은데, 운전(알고리즘)이 문제
→ 해결책: 운전자(알고리즘) 교체!


상황 2: 악조건 문제
━━━━━━━━━━━━━━━━━━━━━━
도로: 🧊 빙판길 (어려운 문제)
운전: 🚗 아무리 잘해도
결과: 미끄러짐 💥

→ 운전(알고리즘)을 아무리 잘해도 도로(문제)가 위험
→ 해결책: 도로 상태 개선 (문제 재정의)
```

---

## 💡 수치적 불안정성 (Numerical Instability)

### 정의

> **계산 방법(알고리즘)**이 작은 오차를 크게 증폭시키는 현상

문제 자체는 괜찮지만, **계산하는 방식**이 나빠서 결과가 엉망이 되는 경우입니다.

### 구체적인 예시: Explicit FDM의 발산

옵션 가격을 계산하는 상황을 생각해 봅시다.

```
정상적인 계산 (안정):
━━━━━━━━━━━━━━━━━━━━
시점 0: [10.0, 10.0, 10.0]
시점 1: [10.1, 10.2, 10.1]
시점 2: [10.2, 10.3, 10.2]
시점 3: [10.3, 10.4, 10.3]
→ 정상적으로 수렴 ✓


불안정한 계산 (발산):
━━━━━━━━━━━━━━━━━━━━
시점 0: [10.0, 10.0, 10.0]
시점 1: [10.1, 9.8, 10.1]   ← 작은 진동 시작
시점 2: [10.5, 9.0, 10.5]   ← 진동 커짐
시점 3: [12.0, 5.0, 12.0]   ← 더 커짐
시점 4: [20.0, -10.0, 20.0] ← 음수?! 말도 안 됨
시점 5: [100, -200, 100]    ← 완전 폭발! 💥
```

**같은 문제**인데 계산 방법(Explicit FDM의 시간 간격)이 잘못되면 이렇게 발산합니다.

### 왜 이런 일이 생기나요?

매 단계에서 작은 오차가 **곱해지면서** 커지기 때문입니다.

```
비유: 소문 전파

원래 이야기: "철수가 밥을 먹었다"

1단계 전파: "철수가 밥을 많이 먹었다" (약간 과장)
2단계 전파: "철수가 엄청 먹었다" (더 과장)
3단계 전파: "철수가 10인분을 먹었다" (과장 폭발)
...
→ 작은 변형이 누적되어 엉뚱한 결과!
```

### 수치적 불안정성의 해결책

| 해결책 | 설명 |
|-------|------|
| **다른 알고리즘 사용** | Explicit → Implicit 전환 |
| **시간 간격 조정** | $\Delta t$ 줄이기 |
| **안정한 방법 선택** | Crank-Nicolson 등 |

**핵심**: 알고리즘을 바꾸면 해결됩니다!

---

## 💡 악조건 문제 (Ill-Conditioned Problem)

### 정의

> **문제 자체**가 입력의 작은 변화에 매우 민감한 경우

어떤 알고리즘을 사용해도, 입력이 조금만 바뀌면 결과가 확 바뀝니다.

### 구체적인 예시: 거의 평행한 두 직선의 교점

두 직선의 교점을 구하는 문제를 생각해 봅시다.

**좋은 조건의 문제** (직선이 뚜렷하게 만남):

```
    y
    ↑    ╲    ╱
    │     ╲  ╱
    │      ╲╱  ← 교점이 명확!
    │      ╱╲
    │     ╱  ╲
    └──────────→ x
```

입력을 조금 바꿔도 교점은 거의 그대로입니다.

**악조건 문제** (직선이 거의 평행):

```
    y
    ↑    ──────────
    │    ──────────  ← 거의 평행!
    │
    │    어디서 만나지...?
    └──────────────→ x
```

입력을 아주 조금만 바꿔도 교점이 **완전히 다른 곳**으로 이동합니다!

### 숫자로 보는 예시

$$\begin{cases} x + y = 2 \\ x + 1.001y = 2.001 \end{cases}$$

정답: $x = 1, y = 1$

이제 두 번째 식의 오른쪽을 **0.001** 만 바꿔봅시다:

$$\begin{cases} x + y = 2 \\ x + 1.001y = 2.002 \end{cases}$$

새 답: $x = 0, y = 2$ ← **완전히 다른 답!**

```
입력 변화: 2.001 → 2.002 (0.05% 변화)
출력 변화: (1,1) → (0,2) (100% 변화!)
```

### 조건수 (Condition Number)

악조건의 정도를 **숫자로** 측정할 수 있습니다:

$$\kappa(A) = \|A\| \times \|A^{-1}\|$$

| 조건수 $\kappa$ | 의미 |
|----------------|------|
| ≈ 1 | 아주 좋은 조건 👍 |
| 10~100 | 괜찮음 |
| 1000~10000 | 주의 필요 ⚠️ |
| > $10^6$ | 심각한 악조건 🚨 |

**직관적 의미**: 조건수가 1000이면, 입력의 0.1% 오차가 출력의 100% 오차로 증폭될 수 있음!

#### 고유값으로 이해하는 조건수

대칭 행렬에서 조건수는 더 직관적으로 표현됩니다:

$$\kappa(A) = \frac{|\lambda_{max}|}{|\lambda_{min}|}$$

##### 고유값(Eigenvalue)과 고유벡터(Eigenvector)란?

**고유벡터** = 행렬이 **단순하게 작동하는 특별한 방향**
**고유값** = 그 방향으로 **얼마나 늘어나는지**

```
행렬 A = [3  1]  의 경우:
         [1  3]

고유벡터 v₁ = (1, 1) 방향  →  고유값 λ₁ = 4
고유벡터 v₂ = (1,-1) 방향  →  고유값 λ₂ = 2

의미: v₁ 방향으로는 4배, v₂ 방향으로는 2배 늘어남
```

핵심: 고유벡터 방향에서는 행렬이 **그냥 숫자 곱하기**처럼 작동!
```
아무 방향:     A × 벡터 = 복잡한 변환
고유벡터 방향: A × v₁ = 4 × v₁  ← 그냥 4배!
```

##### 왜 타원을 생각하나?

단위원에 행렬을 적용하면 **타원**이 됩니다:

```
적용 전 (단위원)           적용 후 (타원)

     ╭───╮                ╭─────────╮
    ╱     ╲              ╱           ╲
   │   ●   │    →       │     ●     │
    ╲     ╱              ╲           ╱
     ╰───╯                ╰─────────╯

반지름 = 1              v₁방향: λ₁배
                        v₂방향: λ₂배
```

**타원의 축 = 고유벡터, 축의 길이 = 고유값**

##### 왜 역행렬을 고려하나?

연립방정식 $A\mathbf{x} = \mathbf{b}$를 푸는 건 결국:

$$\mathbf{x} = A^{-1}\mathbf{b}$$

실제로는 $\mathbf{b}$에 측정 오차 $\varepsilon$이 있습니다:

```
계산 결과: x = A⁻¹(b + ε) = A⁻¹b + A⁻¹ε
                            ────   ─────
                            정답   오차 증폭분
```

**$A^{-1}$이 오차에 곱해지므로**, 역행렬의 성질이 중요합니다!

##### 역행렬의 고유값 = 원래의 역수

```
A의 고유값:    λ_max = 1000,  λ_min = 0.001
A⁻¹의 고유값:         0.001,         1000
                                      ↑
                    작은 λ → 역수 취하면 엄청 커짐!
```

오차가 $\lambda_{min}$ 방향 성분을 가지면:
```
원래 오차:   ε = 0.001
증폭된 오차: A⁻¹ε = 0.001 × (1/0.001) = 1

→ 0.1% 오차가 100%로 증폭!
```

##### 정리

```
조건수 = λ_max / λ_min
       = 타원이 얼마나 찌그러졌나
       = 역행렬에서 오차가 얼마나 증폭될 수 있나
```

### 악조건 문제의 해결책

| 해결책 | 설명 |
|-------|------|
| **전처리 (Preconditioning)** | 문제를 변환해서 조건수 개선 |
| **정규화 (Regularization)** | 제약 조건 추가로 문제 완화 |
| **높은 정밀도 사용** | float → double → quad |
| **문제 재정의** | 다른 형태로 문제를 다시 설정 |

**핵심**: 문제 자체를 바꿔야 합니다! (알고리즘만 바꿔서는 해결 안 됨)

---

## 💡 둘의 차이 정리

### 표로 비교

| 구분 | 수치적 불안정성 | 악조건 문제 |
|-----|--------------|-----------|
| **원인** | 알고리즘 | 문제 자체 |
| **비유** | 나쁜 운전 | 미끄러운 도로 |
| **진단법** | 다른 알고리즘으로 비교 | 조건수 계산 |
| **해결책** | 알고리즘 변경 | 문제 재정의/전처리 |

### 그림으로 비교

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│   입력 ──→ [문제] ──→ [알고리즘] ──→ 출력          │
│              ↑            ↑                        │
│              │            │                        │
│         악조건은        불안정성은                  │
│         여기 문제       여기 문제                   │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 진단하는 방법

**Q: 같은 문제를 다른 알고리즘으로 풀면?**

- 결과가 **비슷하면** → 알고리즘은 OK, **악조건 문제**일 가능성
- 결과가 **다르면** → **수치적 불안정성** (나쁜 알고리즘 사용 중)

---

## 💡 금융에서의 예시

### 수치적 불안정성 예

**상황**: 높은 변동성 옵션을 Explicit FDM으로 가격 계산

```
변동성 50%로 계산 → 결과: 10.25
변동성 80%로 계산 → 결과: -∞ (발산!)
```

**해결**: Implicit 또는 Crank-Nicolson 방법 사용

### 악조건 문제 예

**상황**: 비슷한 주식들로 포트폴리오 최적화

```
종목: 삼성전자, SK하이닉스, LG전자 (비슷한 움직임)

공분산 행렬의 조건수: 100,000 (매우 큼!)

결과: "삼성 100%, SK -50%, LG 50%"
다음 날: "삼성 -30%, SK 80%, LG 50%"
→ 입력 데이터가 조금 바뀌었을 뿐인데 결과가 완전히 다름!
```

**해결**: 정규화(Regularization) 적용, 또는 Factor Model 사용

---

## ✅ 최종 답안

### 수치적 불안정성 (Numerical Instability)

- **정의**: 알고리즘이 작은 오차를 증폭시키는 현상
- **원인**: 계산 방법(알고리즘)의 문제
- **예시**: Explicit FDM에서 시간 간격이 너무 클 때 발산
- **해결**: 안정한 알고리즘으로 교체 (예: Implicit 방법)

### 악조건 문제 (Ill-Conditioned Problem)

- **정의**: 문제 자체가 입력에 매우 민감한 경우
- **원인**: 문제의 본질적 특성
- **예시**: 거의 평행한 두 직선의 교점, 거의 특이한 행렬
- **해결**: 전처리, 정규화, 또는 문제 재정의

### 핵심 차이

> **불안정성**: "운전을 잘못해서" 사고 → 운전자(알고리즘) 교체
>
> **악조건**: "도로가 미끄러워서" 사고 → 도로(문제) 개선

---

**작성일**: 2025-12-03
**과목**: 금융수치해석기법 기말고사 2024
