# 문제 3: 부동소수점 (10점)

## 📚 강의 노트 참조
- **Lecture 01: Numerical Methods Introduction**
  - p.6-7: Floating point representation
  - p.9-10: Machine epsilon and precision

---

## 📋 원본 문제

> **문제 3 (10점)**
>
> 5비트 부동소수점을 다음과 같이 정의한다:
> - 1비트 부호 (s)
> - 2비트 지수부 ($e_1 e_2$)
> - 2비트 가수부 ($n_1 n_2$)
> - 표현: $x = (-1)^s \times 1.n_1 n_2 \times 2^{e-1}$ (단, $e = e_1 \times 2 + e_2$)
>
> **(1)** 5비트 부동소수점으로 표현 가능한 실수의 총 개수를 구하시오. (5점)
>
> **(2)** Machine epsilon을 구하시오. (5점)

---

## 🎯 먼저 "부동소수점"이 뭔지 이해합시다

### 컴퓨터는 숫자를 어떻게 저장하나요?

컴퓨터는 **0과 1만** 사용합니다. 그래서 실수를 저장하려면 특별한 방법이 필요해요.

### "부동소수점"의 의미

**부동 = 떠다닌다 = floating**
**소수점 = decimal point**

소수점이 **고정되지 않고 떠다니는** 표현 방식입니다.

### 예시로 이해하기

같은 숫자를 여러 방식으로 쓸 수 있어요:

```
123.45 = 1.2345 × 10²
       = 12.345 × 10¹
       = 0.12345 × 10³

소수점 위치가 변하고, 대신 지수가 조절됨!
```

컴퓨터는 이런 형태로 저장합니다:
$$\text{숫자} = \pm 1.\text{xxxx} \times 2^{\text{지수}}$$

---

## 💡 문제의 5비트 시스템 분석

### 5비트의 구조

```
┌───┬───┬───┬───┬───┐
│ s │e₁ │e₂ │n₁ │n₂ │
└───┴───┴───┴───┴───┘
  ↓   ↓───↓   ↓───↓
부호  지수부  가수부
(±)  (크기)  (정밀도)
```

- **부호 (s)**: 양수(0) 또는 음수(1)
- **지수부 (e₁e₂)**: 숫자의 "규모" 결정
- **가수부 (n₁n₂)**: 숫자의 "세부 값" 결정

### 실제 값으로 변환하는 공식

$$x = (-1)^s \times 1.n_1 n_2 \times 2^{e-1}$$

여기서 $e = e_1 \times 2 + e_2$ (2진수를 10진수로)

---

## 💡 (1) 표현 가능한 실수의 개수

### 생각의 과정

5비트 = 5개의 칸, 각 칸에 0 또는 1

**몇 가지 조합이 가능할까요?**

### 계산

$$\text{조합 수} = 2 \times 2 \times 2 \times 2 \times 2 = 2^5 = 32$$

### 모든 조합 나열 (일부)

```
00000 → 첫 번째 숫자
00001 → 두 번째 숫자
00010 → 세 번째 숫자
...
11110 → 31번째 숫자
11111 → 32번째 숫자
```

### ✅ 답: **32개**

---

### 참고: 구체적인 값들

몇 가지 예를 계산해 볼까요?

**예시 1**: `00000`
- s=0 (양수), e₁e₂=00 (e=0), n₁n₂=00
- $x = (+1) \times 1.00_2 \times 2^{0-1} = 1 \times 2^{-1} = 0.5$

**예시 2**: `00101`
- s=0, e₁e₂=01 (e=1), n₁n₂=01
- $x = 1.01_2 \times 2^{1-1} = 1.01_2 \times 2^0 = 1.25$

**예시 3**: `10110`
- s=1 (음수), e₁e₂=01 (e=1), n₁n₂=10
- $x = (-1) \times 1.10_2 \times 2^0 = -1.5$

---

## 💡 (2) Machine Epsilon

### Machine Epsilon이 뭔가요?

**"1에 더했을 때, 컴퓨터가 1과 구분할 수 있는 가장 작은 양수"**

$$\epsilon_m = \min\{x > 0 : 1 + x > 1 \text{ (컴퓨터 계산에서)}\}$$

### 왜 중요한가요?

Machine Epsilon은 컴퓨터의 **정밀도 한계**를 나타냅니다.

```
컴퓨터에서:
  1 + 0.1 = 1.1  ✓ (구분 가능)
  1 + 0.01 = 1.01 ✓ (구분 가능)
  ...
  1 + ε = 1 + ε  ✓ (겨우 구분 가능)
  1 + (ε/2) = 1  ✗ (구분 못함! 그냥 1로 처리됨)
```

### 이 문제에서 구해봅시다

#### Step 1: "1"을 이 시스템에서 표현

1을 $1.n_1 n_2 \times 2^{e-1}$ 형태로 쓰면:

$$1 = 1.00_2 \times 2^0$$

따라서 $e = 1$ (즉, $e_1 e_2 = 01$), $n_1 n_2 = 00$

#### Step 2: 1보다 큰 "다음 숫자" 찾기

가수부를 최소 단위만큼 증가시킵니다:

$$n_1 n_2 = 00 \to 01$$

새로운 숫자:
$$1.01_2 \times 2^0$$

#### Step 3: 이진수 → 십진수 변환

$$1.01_2 = 1 + 0 \times 2^{-1} + 1 \times 2^{-2} = 1 + 0 + 0.25 = 1.25$$

#### Step 4: Machine Epsilon 계산

$$\epsilon_m = 1.25 - 1 = 0.25$$

### ✅ 답: **$\epsilon_m = 0.25$ (또는 $\frac{1}{4}$)**

---

### 일반 공식

가수부가 $p$ 비트이면:

$$\epsilon_m = 2^{-p}$$

이 문제에서 $p = 2$이므로:
$$\epsilon_m = 2^{-2} = 0.25$$

---

### 직관적 이해

```
가수부 2비트로 표현 가능한 값들:

1.00 ─────●───────────────────── 1.00
          │
          │ ← 이 간격이 ε = 0.25
          │
1.01 ─────●───────────────────── 1.25
          │
          │
          │
1.10 ─────●───────────────────── 1.50
          │
          │
          │
1.11 ─────●───────────────────── 1.75

→ 1과 그 다음 숫자 사이의 간격 = 0.25
→ 이것이 Machine Epsilon!
```

---

### 실제 컴퓨터와 비교

| 시스템 | 가수부 비트 | Machine Epsilon |
|-------|-----------|-----------------|
| 이 문제 (5비트) | 2 | 0.25 |
| 실제 float (32비트) | 23 | ≈ $1.2 \times 10^{-7}$ |
| 실제 double (64비트) | 52 | ≈ $2.2 \times 10^{-16}$ |

실제 컴퓨터는 훨씬 정밀하지만, 원리는 같습니다!

---

## ✅ 최종 답안

### (1) 표현 가능한 실수 개수

$$2^5 = \boxed{32\text{개}}$$

### (2) Machine Epsilon

가수부가 2비트이므로:
$$\epsilon_m = 2^{-2} = \boxed{0.25}$$

---

**작성일**: 2025-12-03
**과목**: 금융수치해석기법 기말고사 2024
