# 금융수치해석기법 기말고사 2024 - 해설

이 문서는 기말고사 문제를 이해하기 위한 **직관적인 설명**을 제공합니다.
수식보다 개념 이해를 먼저 하세요!

---

## 목차
1. [문제 1: 절단 오차와 반올림 오차](#문제-1-절단-오차와-반올림-오차-10점)
2. [문제 2: Explicit FDM](#문제-2-explicit-fdm-10점)
3. [문제 3: 부동소수점](#문제-3-부동소수점-10점)
4. [문제 4: 뉴턴 방법](#문제-4-뉴턴-방법-10점)
5. [문제 5: SOR 방법](#문제-5-sor-방법-15점)
6. [문제 6: 수치적 불안정성 vs 악조건](#문제-6-수치적-불안정성-vs-악조건-10점)
7. [문제 7: Implicit FDM 이산화](#문제-7-implicit-fdm-이산화-20점)
8. [문제 8: 직접법으로 선형방정식 풀기](#문제-8-직접법으로-선형방정식-풀기-15점)

---

# 문제 1: 절단 오차와 반올림 오차 (10점)

## 문제 요약

중심차분 공식으로 미분계수를 계산할 때:
```
∂f/∂x ≈ [f(x+ε) - f(x-ε)] / 2ε
```

ε의 크기에 따라 오차가 어떻게 달라지나요?

## 핵심 개념

### 절단 오차 (Truncation Error)

**정의**: 미분을 유한차분으로 **근사**할 때 발생하는 오차

```
실제 미분:  f'(x) = lim_{ε→0} [f(x+ε) - f(x-ε)] / 2ε

우리 계산: f'(x) ≈ [f(x+ε) - f(x-ε)] / 2ε  (ε ≠ 0)

차이 = 절단 오차!
```

**왜 발생하나?**
- 테일러 전개의 고차항을 무시하기 때문
- 중심차분은 O(ε²) 정확도 → ε이 0.01이면 오차는 약 0.0001

**ε과의 관계**:
- ε이 **작아지면** → 절단 오차 **감소** ✓
- 더 정확한 근사가 됨!

### 반올림 오차 (Rounding Error)

**정의**: 컴퓨터가 실수를 **유한 자릿수**로 표현할 때 발생하는 오차

**왜 발생하나?**
```
f(x+ε) = 1.000000123456789...
f(x-ε) = 1.000000123456123...

차이 = 0.000000000000666...  ← 아주 작은 수!

컴퓨터: "유효숫자가 거의 사라졌네..."
→ 의미있는 자릿수 손실 (Catastrophic Cancellation)
```

**ε과의 관계**:
- ε이 **작아지면** → 반올림 오차 **증가** ✗
- 비슷한 두 수의 뺄셈 → 유효숫자 손실!

### 트레이드오프 (Trade-off)

```
오차
  ↑
  │  ╲        ╱
  │   ╲반올림╱
  │    ╲    ╱
  │     ╲  ╱
  │ 절단 ╲╱  ← 최적의 ε
  │       ╲
  └──────────────→ ε
  작음        큼
```

**결론**: 최적의 ε이 존재함!
- ε이 너무 크면 → 절단 오차가 지배
- ε이 너무 작으면 → 반올림 오차가 지배

---

# 문제 2: Explicit FDM (10점)

## (1) 오차를 줄이면서 계산 시간 최소화 (5점)

### 답변

**방법 1: Richardson 외삽법**
```
두 가지 격자 크기로 계산:
  - 큰 격자: 가격₁ (빠름, 덜 정확)
  - 작은 격자: 가격₂ (느림, 더 정확)

외삽: 가격_최종 = (4×가격₂ - 가격₁) / 3
→ 격자를 절반으로만 줄여도 정확도 대폭 향상!
```

**방법 2: Crank-Nicolson 사용**
```
Explicit: 정확도 O(Δt, ΔS²) - 1차
Crank-Nicolson: 정확도 O(Δt², ΔS²) - 2차!

같은 격자 크기로 훨씬 정확한 결과
```

**방법 3: 비균등 격자**
```
행사가 근처: 촘촘한 격자 (중요한 영역)
멀리 떨어진 곳: 성긴 격자 (덜 중요)

→ 총 격자 수 유지하면서 정확도 향상
```

## (2) 발산하는 원인과 해결책 (5점)

### 원인: 높은 변동성 (σ)

**안정성 조건 (CFL 조건)**:
```
Explicit FDM이 안정하려면:
  Δt ≤ ΔS² / (σ²S²)

변동성 σ가 증가하면?
  - 우변이 작아짐
  - 같은 Δt로는 조건 위반!
  - 결과: 진동 → 발산!
```

**비유**:
```
파도(변동성)가 세지면 → 배가 흔들림
작은 시간 간격(Δt)으로 자주 조정해야 안정

σ↑ → "파도가 세졌어!" → 더 자주 조정 필요
```

### 해결책

**방법 1: Δt 줄이기**
```
Δt를 절반으로 → 시간 스텝 2배
계산 시간 증가하지만 안정성 확보
```

**방법 2: Implicit 또는 Crank-Nicolson 사용**
```
Implicit 방법: 무조건 안정 (Unconditionally Stable)
어떤 Δt를 사용해도 발산하지 않음!

단점: 매 시점마다 행렬 방정식 풀어야 함
장점: 큰 Δt 사용 가능 → 총 계산 시간 오히려 감소!
```

---

# 문제 3: 부동소수점 (10점)

## (1) 5bit로 표현 가능한 실수 개수 (5점)

### 답변: **32개**

```
5비트 = 2⁵ = 32가지 조합

00000, 00001, 00010, ..., 11111
→ 32개의 서로 다른 값 표현 가능
```

## (2) Machine Epsilon (5점)

### 문제 조건
- 1bit: 부호 (s)
- 2bit: 지수부 (e₁e₂)
- 2bit: 가수부 (n₁n₂)
- 표현: x = (-1)^s × 1.n₁n₂ × 2^(e-1)

### Machine Epsilon이란?

```
1에 더했을 때 1보다 커지는 가장 작은 양수

1 + ε > 1 을 만족하는 최소 ε
```

### 계산

가수부가 2비트이므로:
```
1.00 (2진수) = 1 (10진수)
1.01 (2진수) = 1 + 0.25 = 1.25 (10진수)
1.10 (2진수) = 1 + 0.5 = 1.5 (10진수)
1.11 (2진수) = 1 + 0.75 = 1.75 (10진수)

가장 작은 구분 단위 = 0.01(2진수) = 2^(-2) = 0.25
```

### 답변: **ε = 0.25 (또는 1/4)**

**의미**:
```
이 5비트 시스템에서:
1.0 + 0.24 = 1.0  (구분 못함!)
1.0 + 0.25 = 1.25 (구분 가능!)

실제 컴퓨터(64비트): ε ≈ 10^(-16) (훨씬 정밀)
```

---

# 문제 4: 뉴턴 방법 (10점)

## (1) 단변량 함수의 업데이트 공식 (5점)

### 최적화 문제

f(x)의 **최소/최대값**을 찾으려면 f'(x) = 0인 점을 찾아야 함

### Newton's Method 유도

```
현재 위치: xₙ
목표: f'(x) = 0 인 점 찾기

f'(x)를 xₙ 근처에서 선형 근사:
  f'(x) ≈ f'(xₙ) + f''(xₙ)(x - xₙ)

이것을 0으로 놓으면:
  0 = f'(xₙ) + f''(xₙ)(x - xₙ)

x에 대해 정리:
  x = xₙ - f'(xₙ) / f''(xₙ)
```

### 답변

```
x_{n+1} = xₙ - f'(xₙ) / f''(xₙ)
```

**직관적 이해**:
```
현재 위치의 기울기(1차 미분): 어느 방향?
현재 위치의 곡률(2차 미분): 얼마나 갈까?

기울기 ÷ 곡률 = 이동 거리
```

## (2) 다변량 함수의 업데이트 방법 (5점)

### 기호 설명
- ∇f(x): Gradient 벡터 (각 변수에 대한 1차 편미분)
- ∇²f(x): Hessian 행렬 (2차 편미분들의 행렬)

### 답변

```
x_{n+1} = xₙ - [∇²f(xₙ)]^(-1) · ∇f(xₙ)
```

또는 동등하게:
```
단계 1: Hessian × d = -Gradient 풀기
        ∇²f(xₙ) · d = -∇f(xₙ)

단계 2: 업데이트
        x_{n+1} = xₙ + d
```

**왜 역행렬 대신 방정식을 푸나?**
```
역행렬 계산: O(n³) + O(n²) = 비쌈!
방정식 풀기: O(n³/3) = 더 빠름!
```

---

# 문제 5: SOR 방법 (15점)

## 문제 조건

```
A = [2   4]    b = [ 6]    ω = 2
    [2  -4]        [-2]
```

## (1) M과 N 구하기 (10점)

### SOR 반복식

```
Mx^(k+1) = Nx^(k) + b
```

### 단계별 풀이

**1단계: A를 분해**
```
A = D + L + U

D (대각): [2   0]     L (하삼각): [0  0]     U (상삼각): [0  4]
          [0  -4]                 [2  0]                 [0  0]
```

**2단계: SOR 공식 적용**
```
SOR: (D + ωL)x^(k+1) = [(1-ω)D - ωU]x^(k) + ωb

ω = 2 대입:
  M = D + 2L
  N = (1-2)D - 2U = -D - 2U
  b_new = 2b
```

**3단계: M 계산**
```
M = D + 2L
  = [2   0] + 2×[0  0]
    [0  -4]     [2  0]

  = [2   0] + [0  0]
    [0  -4]   [4  0]

  = [2   0]
    [4  -4]
```

**4단계: N 계산**
```
N = -D - 2U
  = -[2   0] - 2×[0  4]
    [0  -4]     [0  0]

  = [-2   0] + [0  -8]
    [0    4]   [0   0]

  = [-2  -8]
    [ 0   4]
```

### 답변
```
M = [2   0]       N = [-2  -8]
    [4  -4]           [ 0   4]
```

## (2) e^(k+1) 구하기 (5점)

### 조건
```
e^(k) = [-1, 1]^T  (오차 벡터)
```

### 오차 전파 관계
```
Me^(k+1) = Ne^(k)
```

### 단계별 풀이

**1단계: Ne^(k) 계산**
```
Ne^(k) = [-2  -8] × [-1]
         [ 0   4]   [ 1]

       = [(-2)×(-1) + (-8)×1]
         [  0×(-1)  +   4×1]

       = [2 - 8]   = [-6]
         [0 + 4]     [ 4]
```

**2단계: Me^(k+1) = [-6, 4]^T 풀기**
```
[2   0] × [e₁]   = [-6]
[4  -4]   [e₂]     [ 4]

행 1: 2e₁ = -6
      → e₁ = -3

행 2: 4e₁ - 4e₂ = 4
      4×(-3) - 4e₂ = 4
      -12 - 4e₂ = 4
      -4e₂ = 16
      → e₂ = -4
```

### 답변
```
e^(k+1) = [-3, -4]^T
```

**의미**:
```
오차가 커지고 있음!
[-1, 1] → [-3, -4]

이 SOR은 ω=2로 발산하는 중...
(보통 0 < ω < 2 사용)
```

---

# 문제 6: 수치적 불안정성 vs 악조건 (10점)

## 수치적 불안정성 (Numerical Instability)

### 정의
**알고리즘**의 문제 (문제 자체가 아님!)

### 특징
```
작은 오차가 반복을 통해 증폭됨

예시:
  반복 1: 오차 = 0.001
  반복 2: 오차 = 0.01
  반복 3: 오차 = 0.1
  ...
  → 폭발!
```

### 예시
- Explicit FDM에서 CFL 조건 위반
- 고유값이 1보다 큰 반복 행렬

### 해결책
```
✓ 안정한 알고리즘 사용 (Implicit 방법)
✓ 시간 스텝 줄이기
✓ Backward stable 알고리즘 선택
```

## 악조건 문제 (Ill-Conditioned)

### 정의
**문제 자체**가 민감함 (알고리즘이 아님!)

### 특징
```
입력의 작은 변화 → 출력의 큰 변화

예시:
  A = [1.0  1.0]    b = [2.0]
      [1.0  1.001]      [2.001]

  실제 해: x = [1, 1]

  b를 조금만 바꾸면?
  b' = [2.0, 2.002] → x' = [0, 2]  ← 완전히 다른 해!
```

### 측정 방법
```
조건수 (Condition Number): κ(A) = ||A|| × ||A^(-1)||

κ(A) ≈ 1: 좋은 조건
κ(A) >> 1: 악조건 (민감한 문제)
```

### 해결책
```
✓ 전처리 (Preconditioning): 조건수 개선
✓ 정규화 (Regularization): 문제 완화
✓ 더 높은 정밀도 사용 (double → quad)
```

## 비교 요약

| 구분 | 수치적 불안정성 | 악조건 |
|-----|--------------|-------|
| **원인** | 알고리즘 | 문제 자체 |
| **비유** | 나쁜 운전 | 미끄러운 도로 |
| **해결** | 알고리즘 바꾸기 | 문제 완화/전처리 |

---

# 문제 7: Implicit FDM 이산화 (20점)

## 문제 조건

```
PDE: V_t + aV_SS + bV_S + cV = 0

그리드:
  S = S_min + i×ΔS  (i = 0, ..., N)
  t = T - k×Δt      (k = 0, ..., M)

v_i^k = V(S_i, t_k)
```

## (1) 내부점 관계식 (5점)

### Implicit 이산화

**시간 미분** (후진차분):
```
V_t ≈ (v_i^(k+1) - v_i^k) / Δt
```

**공간 미분** (중심차분, k+1 시점 사용):
```
V_S ≈ (v_{i+1}^(k+1) - v_{i-1}^(k+1)) / (2ΔS)

V_SS ≈ (v_{i+1}^(k+1) - 2v_i^(k+1) + v_{i-1}^(k+1)) / ΔS²
```

### PDE 대입 및 정리

```
(v_i^(k+1) - v_i^k)/Δt + a(v_{i+1}^(k+1) - 2v_i^(k+1) + v_{i-1}^(k+1))/ΔS²
    + b(v_{i+1}^(k+1) - v_{i-1}^(k+1))/(2ΔS) + c×v_i^(k+1) = 0
```

### 계수 정의
```
α = aΔt/ΔS²
β = bΔt/(2ΔS)
γ = cΔt
```

### 답변
```
(-α + β)v_{i-1}^(k+1) + (1 + 2α + γ)v_i^(k+1) + (-α - β)v_{i+1}^(k+1) = v_i^k
```

## (2) 경계조건 V_SS = 0 (각 5점)

### i = 1 (S_min 근처)

**경계조건 적용**:
```
V_SS(S_min) = 0
→ (v_0 - 2v_1 + v_2)/ΔS² = 0
→ v_0 = 2v_1 - v_2
```

**v_0를 v_1, v_2로 대체하여 정리**:
```
(1 + γ + 2β)v_1^(k+1) + (-2β)v_2^(k+1) = v_1^k
```

### i = N-1 (S_max 근처)

**경계조건 적용**:
```
V_SS(S_max) = 0
→ (v_{N-2} - 2v_{N-1} + v_N)/ΔS² = 0
→ v_N = 2v_{N-1} - v_{N-2}
```

**v_N을 v_{N-1}, v_{N-2}로 대체하여 정리**:
```
(-2β)v_{N-2}^(k+1) + (1 + γ - 2β)v_{N-1}^(k+1) = v_{N-1}^k
```

## (3) Down-and-Out 배리어 조건 (5점)

### 배리어 조건
```
S_min = 녹아웃 배리어
→ 배리어 도달 시 옵션 가치 = 0
→ v_0^(k+1) = 0
```

### i = 1에서의 관계식

**v_0 = 0 대입**:
```
(-α + β)×0 + (1 + 2α + γ)v_1^(k+1) + (-α - β)v_2^(k+1) = v_1^k
```

### 답변
```
(1 + 2α + γ)v_1^(k+1) + (-α - β)v_2^(k+1) = v_1^k
```

**의미**:
```
배리어 조건은 V_SS=0 조건보다 단순함!
그냥 v_0 = 0을 대입하면 끝
```

---

# 문제 8: 직접법으로 선형방정식 풀기 (15점)

## Ax = b를 역행렬 없이 풀기

### 핵심 아이디어

```
❌ 나쁜 방법: x = A^(-1) × b
   - 역행렬 계산: O(n³)
   - 역행렬 × b: O(n²)
   - 총: O(n³) + 수치 오차 큼!

✓ 좋은 방법: 행렬 분해 + 대입법
   - 분해: O(n³/3)
   - 대입: O(n²)
   - 총: O(n³/3) + 수치 오차 작음!
```

## A의 형태에 따른 최적 방법

### 1. 일반 행렬: LU 분해

```
단계 1: A = LU 분해
        L: 하삼각행렬
        U: 상삼각행렬

단계 2: Ly = b 풀기 (전진대입)
        y₁ = b₁/L₁₁
        y₂ = (b₂ - L₂₁y₁)/L₂₂
        ...

단계 3: Ux = y 풀기 (후진대입)
        xₙ = yₙ/Uₙₙ
        x_{n-1} = (y_{n-1} - U_{n-1,n}xₙ)/U_{n-1,n-1}
        ...

복잡도: O(n³/3)
```

### 2. 대칭 양정치 행렬: Cholesky 분해

```
조건: A = A^T 이고 모든 고유값 > 0

단계 1: A = LL^T 분해
        (하삼각 × 하삼각의 전치)

단계 2: Ly = b (전진대입)
단계 3: L^T x = y (후진대입)

복잡도: O(n³/6) ← LU의 절반!
```

### 3. 삼중대각 행렬: Thomas 알고리즘

```
FDM에서 자주 나오는 형태:

[b₁ c₁ 0  0 ]   [x₁]   [d₁]
[a₂ b₂ c₂ 0 ] × [x₂] = [d₂]
[0  a₃ b₃ c₃]   [x₃]   [d₃]
[0  0  a₄ b₄]   [x₄]   [d₄]

특화된 알고리즘으로 해결:
복잡도: O(n) ← 매우 빠름!
```

### 4. 직교성 필요: QR 분해

```
단계 1: A = QR
        Q: 직교행렬 (Q^T Q = I)
        R: 상삼각행렬

단계 2: Rx = Q^T b (후진대입)

복잡도: O(2n³/3)
장점: 수치적으로 안정
```

### 5. 랭크 부족/최소제곱: SVD 분해

```
단계 1: A = UΣV^T
        U, V: 직교행렬
        Σ: 대각행렬 (특이값)

단계 2: x = VΣ⁺U^T b
        Σ⁺: 의사역행렬

복잡도: 가장 비쌈
장점: 가장 안정, 랭크 부족도 처리 가능
```

## 요약표

| A의 형태 | 최적 방법 | 복잡도 | 언제 사용? |
|---------|----------|--------|----------|
| 일반 | LU | O(n³/3) | 기본 선택 |
| 대칭 양정치 | Cholesky | O(n³/6) | 공분산 행렬 등 |
| 삼중대각 | Thomas | O(n) | FDM 문제 |
| 직교성 필요 | QR | O(2n³/3) | 최소제곱 문제 |
| 랭크 부족 | SVD | 가장 비쌈 | 특이 행렬, 회귀분석 |

## 왜 역행렬을 피하나?

```
1. 계산 비용:
   역행렬 O(n³) vs LU O(n³/3) → 3배 차이

2. 수치 오차:
   역행렬은 오차가 누적됨
   분해+대입은 더 안정적

3. 메모리:
   역행렬은 전체 n×n 저장
   삼중대각은 3n만 저장

결론: 실무에서 역행렬은 거의 안 씀!
```

---

## 핵심 요약

| 문제 | 핵심 개념 |
|-----|----------|
| **1번** | 절단 오차(↓)와 반올림 오차(↑)의 트레이드오프 |
| **2번** | Richardson 외삽, Crank-Nicolson, 안정성 조건 |
| **3번** | 5비트 = 32개, 가수부 2비트 → ε = 0.25 |
| **4번** | x_{n+1} = xₙ - f'/f'' (단변량), Hessian^(-1)×Gradient (다변량) |
| **5번** | SOR 분해: M = D+ωL, N = (1-ω)D-ωU |
| **6번** | 불안정성(알고리즘) vs 악조건(문제) |
| **7번** | Implicit 이산화, 경계조건 처리 |
| **8번** | LU/Cholesky/Thomas/QR/SVD 선택 |

---

**작성일**: 2025-12-03
**과목**: 금융수치해석기법 기말고사 2024
